'use strict';
var MACROUTILS = require( 'osg/Utils' );
var Node = require( 'osg/Node' );
var Notify = require( 'osg/Notify' );
var WebGLCaps = require( 'osg/WebGLCaps' );


/**
 * Geometry manage array and primitives to draw a geometry.
 * @class Geometry
 */
var Geometry = function () {

    Node.call( this );
    this.primitives = [];
    this.attributes = {};

    // function is generated for each Shader Program ID
    // which generates a a special "draw"
    // TODO: could be upon hash of combination of attributes
    // (as multiple shader Programs can use same combination of attributes)
    // if GPU supports VAO it's VAO object
    // if GPU doesn't it's a generated function
    this._cacheDrawCall = {};
    // VAO cached data, per combination of vertex buffer
    // program id also the cache key
    this._extVAO = undefined;
    this._isVAO = {};
    this._cacheVertexAttributeBufferList = {};
    this._cacheVertexAttributeIndexList = {};
    this._cacheHasVertexColorAttributeList = {};

    // null means the kdTree builder will skip the kdTree creation
    this._shape = undefined;

};

/** @lends Geometry.prototype */
Geometry.prototype = MACROUTILS.objectLibraryClass( MACROUTILS.objectInherit( Node.prototype, {

    releaseGLObjects: function () {

        if ( this.stateset !== undefined ) this.stateset.releaseGLObjects();

        var keys = window.Object.keys( this.attributes );
        var value;
        var i, l;

        for ( i = 0, l = keys.length; i < l; i++ ) {
            value = this.attributes[ keys[ i ] ];
            value.releaseGLObjects();
        }

        for ( var j = 0, h = this.primitives.length; j < h; j++ ) {
            var prim = this.primitives[ j ];
            if ( prim.getIndices !== undefined ) {
                if ( prim.getIndices() !== undefined && prim.getIndices() !== null ) {
                    prim.indices.releaseGLObjects();
                }
            }
        }

        if ( this._extVAO ) {

            keys = window.Object.keys( this._cacheDrawCall );
            for ( i = 0, l = keys.length; i < l; i++ ) {
                var prgID = keys[ i ];
                if ( this._isVAO[ prgID ] ) {
                    var vao = this._cacheDrawCall[ prgID ];
                    this._extVAO.deleteVertexArrayOES( vao );
                }
            }

        }

    },

    dirty: function () {
        this._cacheDrawCall = {};
    },
    getPrimitives: function () {
        return this.primitives;
    },
    getAttributes: function () {
        // Notify.warn('deprecated use instead getVertexAttributeList');
        return this.getVertexAttributeList();
    },
    getShape: function () {
        return this._shape;
    },
    setShape: function ( shape ) {
        this._shape = shape;
    },
    getVertexAttributeList: function () {
        return this.attributes;
    },
    getPrimitiveSetList: function () {
        return this.primitives;
    },

    drawCallVAO: function ( state, vao, prgID ) {

        var j, m;

        this._extVAO.bindVertexArrayOES( vao );

        var gl = state.getGraphicContext();
        if ( state._currentVAO !== vao ) {

            state.applyVertexAttributeUniforms( this._cacheHasVertexColorAttributeList[ prgID ] );

            var listVABuff = this._cacheVertexAttributeBufferList[ prgID ];
            for ( j = 0, m = listVABuff.length; j < m; j++ ) {

                if ( listVABuff[ j ].isDirty() ) {
                    listVABuff[ j ].compile( gl );
                }
            }

            state._currentVAO = vao;
        }

        var primitives = this.primitives;
        for ( j = 0, m = primitives.length; j < m; j++ ) {
            state.currentIndexVBO = undefined;
            primitives[ j ].draw( state );
        }

        this._extVAO.bindVertexArrayOES( null );
        // make sure no leftover from previous draw
        // or next draw if non vao.
        state.clearAndDisableVertexAttribCache( gl );

    },

    generateDrawCommand: function ( state, program, prgID ) {

        var drawCommand;

        var attribute;

        var attributesCacheKeys = program._attributesCache.getKeys();
        var attributesCacheMap = program._attributesCache;
        var geometryVertexAttributes = this.getVertexAttributeList();

        var i, l, j, m, key, attr, primitives;

        var extVAO = this._extVAO;

        var generated;

        generated = '//generated by Geometry::implementation\n';
        generated += 'state.lazyDisablingOfVertexAttributes();\n';
        generated += 'var attr;\n';


        var listVABuff, listVAIndex;

        if ( extVAO ) {
            listVABuff = [];
            listVAIndex = [];
        }

        for ( i = 0, l = attributesCacheKeys.length; i < l; i++ ) {

            key = attributesCacheKeys[ i ];
            attribute = attributesCacheMap[ key ];
            attr = geometryVertexAttributes[ key ];

            if ( attr === undefined ) {
                continue;
            }

            var attrBuff = this.attributes[ key ];

            var attrBin = attrBuff;
            if ( attrBuff.getBufferArray ) {
                attrBin = attrBin.getBufferArray();
                extVAO = false;
            }

            if ( !attrBin.isValid() ) return undefined;

            // store for later usage at draw time/update
            if ( extVAO ) {

                listVABuff.push( attrBin );
                listVAIndex.push( attribute );
                if ( key === 'Color' ) {
                    this._cacheHasVertexColorAttributeList[ prgID ] = attribute;
                }

            }

            generated += 'attr = this.attributes[\'' + key + '\'];\n';
            generated += 'if (attr.getBufferArray) attr = attr.getBufferArray();\n';
            generated += 'if (!attr.isValid()) return;\n';
            generated += 'state.setVertexAttribArray(' + attribute + ', attr, false);\n';

        }

        if ( !extVAO ) {
            primitives = this.primitives;
            generated += 'state.applyDisablingOfVertexAttributes();\n';
            generated += 'var primitives = this.primitives;\n';
            for ( j = 0, m = primitives.length; j < m; ++j ) {
                generated += 'primitives[' + j + '].draw(state);\n';
            }
            this._isVAO[ prgID ] = false;
        }

        /*jshint evil: true */
        drawCommand = new Function( 'state', generated );
        /*jshint evil: false */


        if ( extVAO ) {

            this._cacheVertexAttributeBufferList[ prgID ] = listVABuff;
            this._cacheVertexAttributeIndexList[ prgID ] = listVAIndex;

            var gl = state.getGraphicContext();
            state.clearAndDisableVertexAttribCache( gl );

            var vao = this._extVAO.createVertexArrayOES();
            this._extVAO.bindVertexArrayOES( vao );
            drawCommand.call( this, state );

            //this._extVAO.bindVertexArrayOES( null );
            //state._currentVAO = null;
            state._currentVAO = vao;

            /*develblock:start*/
            if ( !this._extVAO.isVertexArrayOES( vao ) ) {
                Notify.error( 'VAO broken' );
            }
            /*develblock:end*/


            drawCommand = vao;
            this._isVAO[ prgID ] = true;

        }

        this._cacheDrawCall[ prgID ] = drawCommand;
        return drawCommand;

    },

    drawImplementation: function ( state ) {

        if ( this._extVAO === undefined ) {
            // returns null if no extension
            this._extVAO = WebGLCaps.instance( state.getGraphicContext() ).getWebGLExtension( 'OES_vertex_array_object' );
        }

        var program = state.getLastProgramApplied();
        var prgID = program.getInstanceID();

        var cachedDraw = this._cacheDrawCall[ prgID ];

        if ( cachedDraw === undefined ) {
            // no cache for this combination of vertex attributes
            // compute new Draw Call
            cachedDraw = this.generateDrawCommand( state, program, prgID );
            if ( cachedDraw === undefined ) return;
        }

        if ( this._extVAO && this._isVAO[ prgID ] ) {
            this.drawCallVAO( state, cachedDraw, prgID );
        } else {
            cachedDraw.call( this, state );
        }
    },

    // for testing disabling drawing
    drawImplementationDummy: function ( state ) {
        /*jshint unused: true */
        // for testing only that's why the code is not removed
        var program = state.getLastProgramApplied();
        var attribute;
        var attributeList = [];
        var attributesCache = program._attributesCache;


        var primitives = this.primitives;
        //state.disableVertexAttribsExcept(attributeList);

        for ( var j = 0, m = primitives.length; j < m; ++j ) {
            //primitives[j].draw(state);
        }
        /*jshint unused: false */
    },

    setBound: function ( bb ) {
        this._boundingBox = bb;
        this._boundingBoxComputed = true;
    },

    computeBoundingBox: function ( boundingBox ) {

        var vertexArray = this.getVertexAttributeList().Vertex;
        if ( vertexArray && vertexArray.getElements() && vertexArray.getItemSize() > 2 ) {
            var vertexes = vertexArray.getElements();
            var itemSize = vertexArray.getItemSize();

            var min = boundingBox.getMin();
            var max = boundingBox.getMax();

            var minx = min[ 0 ];
            var miny = min[ 1 ];
            var minz = min[ 2 ];
            var maxx = max[ 0 ];
            var maxy = max[ 1 ];
            var maxz = max[ 2 ];

            // if the box is un-initialized min=Inf and max=-Inf
            // we can't simply write if(x > min) [...] else (x < max) [...]
            // most of the time the else condition is run so it's a kinda useless
            // optimization anyway
            for ( var idx = 0, l = vertexes.length; idx < l; idx += itemSize ) {
                var v1 = vertexes[ idx ];
                var v2 = vertexes[ idx + 1 ];
                var v3 = vertexes[ idx + 2 ];
                if ( v1 < minx ) minx = v1;
                if ( v1 > maxx ) maxx = v1;
                if ( v2 < miny ) miny = v2;
                if ( v2 > maxy ) maxy = v2;
                if ( v3 < minz ) minz = v3;
                if ( v3 > maxz ) maxz = v3;
            }

            min[ 0 ] = minx;
            min[ 1 ] = miny;
            min[ 2 ] = minz;
            max[ 0 ] = maxx;
            max[ 1 ] = maxy;
            max[ 2 ] = maxz;
        }
        return boundingBox;
    },

    computeBoundingSphere: function ( boundingSphere ) {
        boundingSphere.init();
        var bb = this.getBoundingBox();
        boundingSphere.expandByBoundingBox( bb );
        return boundingSphere;
    }


} ), 'osg', 'Geometry' );

Geometry.appendVertexAttributeToList = function ( from, to, postfix ) {

    var keys = window.Object.keys( from );
    var key, keyPostFix;

    for ( var i = 0, l = keys.length; i < l; i++ ) {

        key = keys[ i ];
        keyPostFix = key;
        if ( postfix !== undefined )
            keyPostFix += '_' + postfix;

        to[ keyPostFix ] = from[ key ];

    }

};


MACROUTILS.setTypeID( Geometry );

module.exports = Geometry;
